--- drivers/usb/host/xhci-hub.c
+++ drivers/usb/host/xhci-hub.c
@@ -462,81 +458,6 @@ void xhci_test_and_clear_bit(struct xhci_hcd *xhci, __le32 __iomem **port_array,
 	}
 }
 
-/* Updates Link Status for super Speed port */
-static void xhci_hub_report_link_state(struct xhci_hcd *xhci,
-		u32 *status, u32 status_reg)
-{
-	u32 pls = status_reg & PORT_PLS_MASK;
-
-	/* resume state is a xHCI internal state.
-	 * Do not report it to usb core.
-	 */
-	if (pls == XDEV_RESUME)
-		return;
-
-	/* When the CAS bit is set then warm reset
-	 * should be performed on port
-	 */
-	if (status_reg & PORT_CAS) {
-		/* The CAS bit can be set while the port is
-		 * in any link state.
-		 * Only roothubs have CAS bit, so we
-		 * pretend to be in compliance mode
-		 * unless we're already in compliance
-		 * or the inactive state.
-		 */
-		if (pls != USB_SS_PORT_LS_COMP_MOD &&
-		    pls != USB_SS_PORT_LS_SS_INACTIVE) {
-			pls = USB_SS_PORT_LS_COMP_MOD;
-		}
-		/* Return also connection bit -
-		 * hub state machine resets port
-		 * when this bit is set.
-		 */
-		pls |= USB_PORT_STAT_CONNECTION;
-	} else {
-		/*
-		 * If CAS bit isn't set but the Port is already at
-		 * Compliance Mode, fake a connection so the USB core
-		 * notices the Compliance state and resets the port.
-		 * This resolves an issue generated by the SN65LVPE502CP
-		 * in which sometimes the port enters compliance mode
-		 * caused by a delay on the host-device negotiation.
-		 */
-		if ((xhci->quirks & XHCI_COMP_MODE_QUIRK) &&
-				(pls == USB_SS_PORT_LS_COMP_MOD))
-			pls |= USB_PORT_STAT_CONNECTION;
-	}
-
-	/* update status field */
-	*status |= pls;
-}
-
-/*
- * Function for Compliance Mode Quirk.
- *
- * This Function verifies if all xhc USB3 ports have entered U0, if so,
- * the compliance mode timer is deleted. A port won't enter
- * compliance mode if it has previously entered U0.
- */
-void xhci_del_comp_mod_timer(struct xhci_hcd *xhci, u32 status, u16 wIndex)
-{
-	u32 all_ports_seen_u0 = ((1 << xhci->num_usb3_ports)-1);
-	bool port_in_u0 = ((status & PORT_PLS_MASK) == XDEV_U0);
-
-	if (!(xhci->quirks & XHCI_COMP_MODE_QUIRK))
-		return;
-
-	if ((xhci->port_status_u0 != all_ports_seen_u0) && port_in_u0) {
-		xhci->port_status_u0 |= 1 << wIndex;
-		if (xhci->port_status_u0 == all_ports_seen_u0) {
-			del_timer_sync(&xhci->comp_mode_recovery_timer);
-			xhci_dbg(xhci, "All USB3 ports have entered U0 already!\n");
-			xhci_dbg(xhci, "Compliance Mode Recovery Timer Deleted.\n");
-		}
-	}
-}
-
 int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		u16 wIndex, char *buf, u16 wLength)
 {
